---
layout: post
title: 当系统调用不存在……
categories:
- Deprecated
tags:
- ltp
- makefile
- pre define
published: true
comments: true
---
<p>最近在一个项目上卡了几天，整理出来主要碰到的问题，以备自己查阅。</p>

<p>具体的问题抽象出来就是这么一种情况：</p>

<p>有一堆分层的目录，里面全是系统调用的相关测试代码+Makefile，结构大致如下：</p>

<p><blockquote>
├── wait4<br />
│   ├── Makefile<br />
│   ├── wait401.c<br />
│   └── wait402.c<br />
├── waitid<br />
│   ├── waitid01<br />
│   │   ├── Makefile<br />
│   │   └── waitid01.c<br />
│   ├── waitid02<br />
│   │   ├── Makefile<br />
│   │   └── waitid02.c<br />
├── waitpid<br />
│   │   ├── Makefile<br />
│   │   └── waitpid_err_test.c<br />
.....</blockquote></p>

<p><!--more-->现在要把这堆系统调用的测试代码移植到各硬件平台和各发行版上，因此要考虑内核版本、glibc版本等等问题。比如说getcpu这个东东只在2.6.19及以后版本中存在并且只有x86_64 and i386架构才可用。而编译这堆系统调用使用的Makefile大致如下：</p>

<p><pre lang="bash" line="1">
MAKEFILES_FOR_TESTCASES = $(shell find testcases -name Makefile)
TESTCASES_BY_MAKE = $(addsuffix /test,$(dir $(MAKEFILES_FOR_TESTCASES)))</pre></p>

<p>$(TESTCASES_BY_MAKE):<br />
        $(MAKE) -C $(dir $@) test
</p>

<p>因此可能的解决方案有如下几种：</p>

<p><h4>1. 修改Makefile，禁止编译会出错的测试用例</h4></p>

<p><pre lang="bash" line="1">
FILTER_OUT_CASES = testcase1 testcase2 testcase3
ALL_MAKEFILES = $(shell find testcases -name Makefile)
FILTER_OUT_MAKEFILES = $(wildcard $(foreach filename,$(FILTER_OUT_CASES),testcases/$(filename)/Makefile))
MAKEFILES_FOR_TESTCASES = $(filter-out $(FILTER_OUT_MAKEFILES),$(ALL_MAKEFILES))
TESTCASES_BY_MAKE = $(addsuffix /test,$(dir $(MAKEFILES_FOR_TESTCASES)))</pre></p>

<p>$(TESTCASES_BY_MAKE):<br />
        $(MAKE) -C $(dir $@) test
</p>

<p>代码很平淡无奇，之所以贴出这段代码是为了温习一下Makefile中wildcard,filter-out和foreach的用法 :-)</p>

<p><h4>2.修改c代码，使用预处理判断是否存在</h4></p>

<p>这种办法在<a href="ltp.sf.net/" target="_blank">ltp</a>上应用十分广泛，ltp中自动从configure文件中生成include/config.h，生成的config.h包含了一系列预处理，例如：</p>

<p><pre lang="cpp" line="1">
/* Define to 1 if you have the <sys/signalfd.h> header file. */
#undef HAVE_SYS_SIGNALFD_H</pre></p>

<p>/* Define to 1 if you have the <sys/stat.h> header file. */<br />
#define HAVE_SYS_STAT_H 1
</p>

<p>当内核版本不同导致系统调用不存在时，可以设置undef预处理；如果系统调用存在，则define一下。</p>

<p>接下去可以修改源代码，在可能会在不同内核版本上出现分歧的代码前后加上：</p>

<p><pre lang="cpp" line="1">#ifdef HAVE_SYS_SIGNALFD_H
...
#else
int main()
{
  printf("syscall not exists in this platform\");
  return 1;
}
#endif</pre></p>

<p>同时ltp还在C代码中判断内核版本，内核版本在<sys/utsname.h>中有声明。</p>

<p>如果不使用configure文件，可以自己写一个shell脚本来生成，例如：</p>

<p><pre lang="bash" line="1">
#!/bin/sh</pre></p>

<p>CONFIG_PATH=./include/config.h<br />
KVER=`uname -r | cut -d'-' -f 1`<br />
KMAJVER=`echo $KVER | cut -d'.' -f 1-2`<br />
KMINVER=`echo $KVER | cut -d'.' -f 3`</p>

<p>if [ "$KMAJVER" = "2.6" ] && [ $KMINVER -ge 19 ];<br />
then<br />
	echo '#define HAVE_SYS_EPOLL_H 1' >> $CONFIG_PATH<br />
else<br />
	echo '#ifdef HAVE_SYS_EPOLL_H' >> $CONFIG_PATH<br />
	echo '#  undef HAVE_SYS_EPOLL_H' >> $CONFIG_PATH<br />
	echo '#endif' >> $CONFIG_PATH<br />
fi

</p>
